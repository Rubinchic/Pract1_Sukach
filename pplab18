import asyncio
import os
import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from dotenv import load_dotenv

load_dotenv()
TOKEN = os.getenv("BOT_TOKEN")
API_URL = "https://rubinchic.site/api/movies"

bot = Bot(token=TOKEN)
dp = Dispatcher()

# FSM –¥–ª—è –ø–æ—à—É–∫—É –∑–∞ —Ä–æ–∫–æ–º
class FindYear(StatesGroup):
    waiting_for_year = State()

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ñ—ñ–ª—å–º—ñ–≤ –∑ API
async def fetch_movies():
    async with aiohttp.ClientSession() as session:
        async with session.get(API_URL, ssl=False) as resp:
            data = await resp.json()
            return data

# –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É —Ñ—ñ–ª—å–º—ñ–≤
def format_movie(movie):
    return (
        f"üé¨ <b>{movie['title']}</b>\n"
        f"–†—ñ–∫: {movie['year']}\n"
        f"–ñ–∞–Ω—Ä: {movie['genre']}\n"
        f"–†–µ–∂–∏—Å–µ—Ä: {movie['director']}\n"
        f"–†–µ–π—Ç–∏–Ω–≥: {movie['rating']}\n"
    )

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await message.answer(
        "–í—ñ—Ç–∞—é! –¶–µ –±–æ—Ç-—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è —Ñ—ñ–ª—å–º—ñ–≤ üé¨\n"
        "–î–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–∞–Ω–¥–∏: /movies, /find_by_year, /sort_by_genre, /help, /info, /exit"
    )

@dp.message(Command("help"))
async def cmd_help(message: types.Message):
    await message.answer(
        "/movies ‚Äî –ø–æ–∫–∞–∑–∞—Ç–∏ –≤—Å—ñ —Ñ—ñ–ª—å–º–∏\n"
        "/find_by_year ‚Äî –∑–Ω–∞–π—Ç–∏ —Ñ—ñ–ª—å–º–∏ –∑–∞ —Ä–æ–∫–æ–º\n"
        "/sort_by_genre ‚Äî —Ñ—ñ–ª—å–º–∏ –ø–æ –∂–∞–Ω—Ä–∞—Ö\n"
        "/info ‚Äî —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –±–æ—Ç–∞\n"
        "/exit ‚Äî –∑–∞–≤–µ—Ä—à–∏—Ç–∏ –¥—ñ–∞–ª–æ–≥"
    )

@dp.message(Command("info"))
async def cmd_info(message: types.Message):
    await message.answer(
        "–ë–æ—Ç –æ—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ —Ñ—ñ–ª—å–º—ñ–≤ —ñ–∑ –≤–ª–∞—Å–Ω–æ–≥–æ API —Ç–∞ –¥–æ–∑–≤–æ–ª—è—î —à—É–∫–∞—Ç–∏ —ó—Ö –∑–∞ —Ä–æ–∫–æ–º –∞–±–æ –∂–∞–Ω—Ä–æ–º.\n"
        "API —Å—Ç–≤–æ—Ä–µ–Ω–æ –≤–ª–∞—Å–Ω–æ—Ä—É—á –Ω–∞ Flask: https://rubinchic.site/api/movies\n"
    )

@dp.message(Command("exit"))
async def cmd_exit(message: types.Message):
    await message.answer("–î—è–∫—É—î–º–æ –∑–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è! –î–æ –∑—É—Å—Ç—Ä—ñ—á—ñ üëã")

@dp.message(Command("movies"))
async def cmd_movies(message: types.Message):
    movies_raw = await fetch_movies()
    movies = movies_raw.get("data", [])
    if not movies:
        await message.answer("–ù–µ–º–∞—î —Ñ—ñ–ª—å–º—ñ–≤ —É –±–∞–∑—ñ.")
        return
    text = "\n".join([format_movie(m) for m in movies])
    await message.answer(text, parse_mode="HTML")

@dp.message(Command("find_by_year"))
async def cmd_find_by_year(message: types.Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥—ñ—Ç—å —Ä—ñ–∫, –∑–∞ —è–∫–∏–º —à—É–∫–∞—Ç–∏ —Ñ—ñ–ª—å–º–∏:")
    await state.set_state(FindYear.waiting_for_year)

@dp.message(FindYear.waiting_for_year)
async def process_find_year(message: types.Message, state: FSMContext):
    year = message.text.strip()
    if not year.isdigit():
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–∏–π —Ä—ñ–∫ (—á–∏—Å–ª–æ).")
        return
    movies_raw = await fetch_movies()
    movies = movies_raw.get("data", [])
    found = [m for m in movies if str(m["year"]) == year]
    if not found:
        await message.answer("–§—ñ–ª—å–º—ñ–≤ –∑–∞ —Ü–µ–π —Ä—ñ–∫ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
    else:
        text = "\n".join([format_movie(m) for m in found])
        await message.answer(text, parse_mode="HTML")
    await state.clear()

@dp.message(Command("sort_by_genre"))
async def cmd_sort_by_genre(message: types.Message):
    movies_raw = await fetch_movies()
    movies = movies_raw.get("data", [])
    if not movies:
        await message.answer("–ù–µ–º–∞—î —Ñ—ñ–ª—å–º—ñ–≤ —É –±–∞–∑—ñ.")
        return
    # –ì—Ä—É–ø—É—î–º–æ –ø–æ –∂–∞–Ω—Ä—É
    genres = {}
    for m in movies:
        genres.setdefault(m["genre"], []).append(m)
    text = ""
    for genre, films in genres.items():
        text += f"\n<b>{genre.title()}:</b>\n"
        for m in films:
            text += f"  - {m['title']} ({m['year']})\n"
    await message.answer(text, parse_mode="HTML")

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
